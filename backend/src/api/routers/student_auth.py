"""Student authentication and profile routes."""

from fastapi import APIRouter, HTTPException, Depends, Response, Header
from sqlalchemy.orm import Session
from typing import Dict, Any, Optional, List

from src.database.engine import get_db
from src.database.repositories import AdminRepository, ApplicationRepository
from src.config.settings import get_settings
from src.api.dependencies.auth import get_student_session, get_student_auth_service
from src.services.student_auth import StudentAuthService
from src.api.schemas.api_models import (
    StudentAuthStartResponse,
    StudentAuthCallbackRequest,
    StudentSessionResponse,
    StudentProfileResponse,
    StudentLogoutResponse,
    StudentApplicationsResponse,
    StudentApplicationHistory,
    CycleInfo,
    ApplicationStatusResponse,
    ResultsResponse,
)
from src.models.schemas import InterviewDetails
from src.utils.logger import get_logger

logger = get_logger("api.student_auth")

router = APIRouter(prefix="/auth/student", tags=["Student Authentication"])


@router.post("/google/start", response_model=StudentAuthStartResponse)
async def start_student_google_login(
    redirect_uri: str,
    code_challenge: str,
    db: Session = Depends(get_db),
):
    """Initiates the Google OAuth 2.0 login flow with PKCE.

    This endpoint generates a unique state, stores the provided code challenge,
    and returns the Google authorization URL.

    Args:
        redirect_uri: The URI Google will redirect to after authentication.
        code_challenge: The PKCE code challenge generated by the client.
        db: Database session dependency.

    Returns:
        The authorization URL and the state parameter to be used by the client.
    """
    settings = get_settings()
    auth_service = StudentAuthService(db)

    # The client is responsible for the code_verifier; the server only needs the challenge.
    # The service hashes the verifier later during the callback for validation.
    state_payload = auth_service.create_auth_state(
        code_challenge=code_challenge,
        redirect_uri=redirect_uri,
    )

    authorization_url = (
        f"{auth_service.google_authorize_url}?response_type=code"
        f"&client_id={settings.google_client_id}"
        f"&redirect_uri={redirect_uri}"
        f"&scope=openid%20email%20profile"
        f"&state={state_payload['state']}"
        f"&nonce={state_payload['nonce']}"
        f"&code_challenge={code_challenge}"
        f"&code_challenge_method=S256"
    )

    return StudentAuthStartResponse(
        authorization_url=authorization_url,
        state=state_payload["state"],
    )


@router.post("/google/callback", response_model=StudentSessionResponse)
async def student_google_callback(
    request: StudentAuthCallbackRequest,
    response: Response,
    user_agent: Optional[str] = Header(None),
    db: Session = Depends(get_db),
):
    """Handles the Google OAuth callback, exchanges the code for a session."""
    auth_service = get_student_auth_service(db)
    settings = get_settings()

    try:
        session_details = await auth_service.complete_google_login(
            code=request.code,
            state=request.state,
            code_verifier=request.code_verifier,
            redirect_uri=request.redirect_uri,
            ip_address=None,  # TODO: Get client IP if needed
            user_agent=user_agent,
        )

        response.set_cookie(
            key="enigma_student_session",
            value=session_details["session_token"],
            httponly=True,
            secure=not settings.debug,  # Use secure cookies in production
            samesite="lax",
            expires=session_details["session_expires_at"],
        )

        return StudentSessionResponse(
            success=True,
            student=StudentProfileResponse(
                student_id=session_details["student_id"],
                primary_email=session_details["primary_email"],
                display_name=session_details["display_name"],
                status="active",
            ),
        )

    except HTTPException as e:
        logger.warning(f"Student login failed: {e.detail}")
        raise
    except Exception as e:
        logger.error(f"An unexpected error occurred during student login: {e}")
        raise HTTPException(status_code=500, detail="An internal error occurred.")


@router.get("/me", response_model=StudentProfileResponse)
async def get_current_student(
    student_session: Optional[Dict[str, Any]] = Depends(get_student_session)
):
    """Returns the profile of the currently authenticated student."""
    if not student_session:
        raise HTTPException(status_code=401, detail="Not authenticated")

    # The student_session dictionary now contains the application data.
    # Pydantic will automatically map it to the StudentProfileResponse model.
    return student_session


@router.post("/logout", response_model=StudentLogoutResponse)
async def student_logout(
    response: Response,
    session_token: Optional[str] = Header(None, alias="enigma_student_session"),
    db: Session = Depends(get_db),
):
    """Logs out the student by revoking the session and clearing the cookie."""
    if session_token:
        auth_service = get_student_auth_service(db)
        auth_service.revoke_session(session_token)

    response.delete_cookie("enigma_student_session")
    return StudentLogoutResponse(success=True, message="Logged out successfully")


@router.get("/applications", response_model=StudentApplicationsResponse)
async def get_student_applications(
    student_session: Optional[Dict[str, Any]] = Depends(get_student_session),
    db: Session = Depends(get_db)
):
    """Get all applications for the authenticated student across all cycles."""
    if not student_session:
        raise HTTPException(status_code=401, detail="Not authenticated")

    student_id = student_session["student_id"]
    app_repo = ApplicationRepository(db)
    admin_repo = AdminRepository(db)

    # Get all applications for this student
    applications = app_repo.get_by_student_id(student_id)

    # Build response with cycle info and results
    application_history = []

    for app in applications:
        # Get cycle info
        cycle = admin_repo.get_cycle_by_id(app.admission_cycle_id)
        if not cycle:
            continue  # Skip if cycle not found

        # Get anonymized ID if available
        anonymized_id = None
        try:
            anonymized = app_repo.get_anonymized_by_application_id(app.application_id)
            if anonymized:
                anonymized_id = anonymized.anonymized_id
        except Exception:
            pass

        # Get results if available and published
        results = None
        if anonymized_id:
            try:
                final_score = app_repo.get_final_score_by_anonymized_id(anonymized_id)
                if final_score:
                    status_value = final_score.status.value if hasattr(final_score.status, "value") else str(final_score.status)
                    # Only include results if published, selected, or not_selected
                    if status_value.lower() in ['published', 'selected', 'not_selected']:
                        results = ResultsResponse(
                            anonymized_id=anonymized_id,
                            status=status_value,
                            final_score=final_score.final_score,
                            academic_score=final_score.academic_score,
                            test_score=final_score.test_score,
                            achievement_score=final_score.achievement_score,
                            essay_score=final_score.essay_score,
                            explanation=final_score.explanation,
                            strengths=final_score.strengths,
                            areas_for_improvement=final_score.areas_for_improvement,
                            hash=final_score.hash or "",
                            timestamp=final_score.timestamp,
                            worker_attempts=final_score.worker_attempts
                        )
            except Exception as e:
                logger.warning(f"Could not fetch results for {anonymized_id}: {e}")

        # Get application status
        status_value = app.status.value if hasattr(app.status, "value") else str(app.status)

        # Get cycle phase
        phase_value = cycle.phase.value if hasattr(cycle.phase, "value") else str(cycle.phase)

        # Build history entry
        history_entry = StudentApplicationHistory(
            application_id=app.application_id,
            cycle=CycleInfo(
                cycle_id=cycle.cycle_id,
                cycle_name=cycle.cycle_name,
                start_date=cycle.start_date,
                end_date=cycle.end_date,
                result_date=cycle.result_date,
                phase=phase_value
            ),
            status=status_value,
            submitted_at=app.timestamp,
            anonymized_id=anonymized_id,
            results=results
        )
        application_history.append(history_entry)

    return StudentApplicationsResponse(
        student_id=student_id,
        applications=application_history,
        total_count=len(application_history)
    )
